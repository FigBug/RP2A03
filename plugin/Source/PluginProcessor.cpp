/*
  ==============================================================================

    This file was auto-generated by the Introjucer!

    It contains the basic framework code for a JUCE plugin processor.

  ==============================================================================
*/

#include "PluginProcessor.h"
#include "PluginEditor.h"

const char* RP2A03AudioProcessor::paramPulse1Level      = "pulse1Level";
const char* RP2A03AudioProcessor::paramPulse1DutyCycle  = "pulse1Duty";
const char* RP2A03AudioProcessor::paramPulse1A          = "pulse1A";
const char* RP2A03AudioProcessor::paramPulse1D          = "pulse1D";
const char* RP2A03AudioProcessor::paramPulse1S          = "pulse1S";
const char* RP2A03AudioProcessor::paramPulse1R          = "pulse1R";
const char* RP2A03AudioProcessor::paramPulse2Level      = "pulse2Level";
const char* RP2A03AudioProcessor::paramPulse2DutyCycle  = "pulse2Duty";
const char* RP2A03AudioProcessor::paramTriangleLevel    = "triangleLevel";
const char* RP2A03AudioProcessor::paramNoiseLevel       = "noiseLevel";
const char* RP2A03AudioProcessor::paramNoiseShort       = "noisePeriod";

//==============================================================================
void RP2A03AudioProcessor::ADSR::set (float a_, float d_, float s_, float r_)
{
    a = a_;
    d = d_;
    s = s_;
    r = r_;
}

void RP2A03AudioProcessor::ADSR::start (int level)
{
    maxLevel = 127; //level;
    mode = mAttack;
    tic = ticPerStep = sampleRate * a / maxLevel;
    currentLevel = jmin (currentLevel, maxLevel);
}

void RP2A03AudioProcessor::ADSR::stop()
{
    mode = mRelease;
    tic = ticPerStep = sampleRate * d / currentLevel;
}

bool RP2A03AudioProcessor::ADSR::run (int numSamples)
{
    if (mode == mStop || mode == mSustain)
        return false;
    
    tic -= numSamples;
    
    if (tic <= 0)
    {
        switch (mode)
        {
            case mAttack:
                currentLevel++;
                if (currentLevel >= maxLevel)
                {
                    mode = mDecay;
                    tic = ticPerStep = sampleRate * d / (currentLevel - currentLevel * s);
                    return true;
                }
                tic = ticPerStep;
                return true;
            case mDecay:
                currentLevel--;
                if (currentLevel <= maxLevel * s)
                    mode = mSustain;
                else
                    tic = ticPerStep;
                return true;
            case mRelease:
                currentLevel--;
                if (currentLevel <= 0)
                    mode = mStop;
                else
                    tic = ticPerStep;
                return true;
            default:
                break;
        }
    }
    
    return false;
}

int RP2A03AudioProcessor::ADSR::getCurrentLevel()
{
    return jlimit (0, 0xF, currentLevel);
}

//==============================================================================
RP2A03AudioProcessor::RP2A03AudioProcessor()
{
    addPluginParameter (new slParameter (paramPulse1Level,     "Pulse 1 Level",      "", 0.0f, 1.0f,  0.0f, 1.0f));
    addPluginParameter (new slParameter (paramPulse1DutyCycle, "Pulse 1 Duty Cycle", "", 0.0f, 3.0f,  1.0f, 0.0f));
    addPluginParameter (new slParameter (paramPulse1A,         "Pulse 1 A",          "", 0.0f, 1.0f,  0.0f, 0.0f));
    addPluginParameter (new slParameter (paramPulse1D,         "Pulse 1 D",          "", 0.0f, 1.0f,  0.0f, 0.0f));
    addPluginParameter (new slParameter (paramPulse1S,         "Pulse 1 S",          "", 0.0f, 1.0f,  0.0f, 1.0f));
    addPluginParameter (new slParameter (paramPulse1R,         "Pulse 1 R",          "", 0.0f, 1.0f,  0.0f, 0.0f));
    
    addPluginParameter (new slParameter (paramPulse2Level,     "Pulse 2 Level",      "", 0.0f, 1.0f,  0.0f, 0.0f));
    addPluginParameter (new slParameter (paramPulse2DutyCycle, "Pulse 2 Duty Cycle", "", 0.0f, 3.0f,  1.0f, 0.0f));
    
    addPluginParameter (new slParameter (paramTriangleLevel,   "Triangle Level",     "", 0.0f, 1.0f,  1.0f, 0.0f));
    addPluginParameter (new slParameter (paramNoiseLevel,      "Noise Level",        "", 0.0f, 1.0f,  0.0f, 0.0f));
    addPluginParameter (new slParameter (paramNoiseShort,      "Noise Short",        "", 0.0f, 1.0f,  1.0f, 0.0f));
}

RP2A03AudioProcessor::~RP2A03AudioProcessor()
{
}

//==============================================================================
void RP2A03AudioProcessor::prepareToPlay (double sampleRate, int samplesPerBlock)
{
    apu.sample_rate (sampleRate);
    apu.write_register (0x4015, 0x0F);
    
    p1ADSR.sampleRate = sampleRate;
}

void RP2A03AudioProcessor::releaseResources()
{
}

void RP2A03AudioProcessor::runUntil (int& done, AudioSampleBuffer& buffer, int pos)
{
    int todo = jmin (pos, buffer.getNumSamples()) - done;
    
    while (todo > 0)
    {
        if (apu.samples_avail() == 0)
            apu.step();
        
        Simple_Apu::sample_t out[1024];
        int count = apu.read_samples(out, jmin (todo, int (apu.samples_avail()), 1024));
        
        float* data = buffer.getWritePointer (0, done);
        for (int i = 0; i < count; i++)
            data[i] = out[i] / 32768.0f;
        
        done += count;
        todo -= count;
        
        if (p1ADSR.run (count))
        {
            const int p1Duty    = getParameter (paramPulse1DutyCycle)->getUserValue();

            apu.write_register (0x4000, (p1Duty << 6) | 0x30 | p1ADSR.getCurrentLevel());
        }
    }

}

void RP2A03AudioProcessor::processBlock (AudioSampleBuffer& buffer, MidiBuffer& midi)
{
    const float p1Level = getParameter (paramPulse1Level)->getUserValue();
    const int p1Duty    = getParameter (paramPulse1DutyCycle)->getUserValue();
    const float p1A     = getParameter (paramPulse1A)->getUserValue();
    const float p1D     = getParameter (paramPulse1D)->getUserValue();
    const float p1S     = getParameter (paramPulse1S)->getUserValue();
    const float p1R     = getParameter (paramPulse1R)->getUserValue();
    const float p2Level = getParameter (paramPulse2Level)->getUserValue();
    const int p2Duty    = getParameter (paramPulse2DutyCycle)->getUserValue();
    const float tLevel  = getParameter (paramTriangleLevel)->getUserValue();
    const float nLevel  = getParameter (paramNoiseLevel)->getUserValue();
    const bool nShort   = getParameter (paramNoiseShort)->getUserValue();

    int done = 0;
    runUntil (done, buffer, 0);
    
    p1ADSR.set (p1A, p1D, p1S, p1R);
    
    int pos = 0;
    MidiMessage msg;
    MidiBuffer::Iterator itr (midi);
    while (itr.getNextEvent (msg, pos))
    {
        runUntil (done, buffer, pos);
        
        if (msg.isNoteOn())
        {
            noteQueue.add (msg.getNoteNumber());
            velocity = msg.getVelocity();
            
            printf ("Note on: %d\n", msg.getNoteNumber());
        }
        else if (msg.isNoteOff())
        {
            noteQueue.removeFirstMatchingValue (msg.getNoteNumber());
            
            printf ("Note off: %d\n", msg.getNoteNumber());
        }
        else if (msg.isAllNotesOff())
        {
            noteQueue.clear();
            
            printf ("All notes off\n");
        }
        
        const int curNote = noteQueue.size() > 0 ? noteQueue.getFirst() : -1;
        
        if (curNote != lastNote)
        {
            int v = curNote == -1 ? 0 : velocity;
            
            // Pulse 1
            if (v == 0)
                p1ADSR.stop();
            else
                p1ADSR.start (int (p1Level * v / 127.0 * 0xF));
            
            apu.write_register (0x4000, (p1Duty << 6) | 0x30 | p1ADSR.getCurrentLevel());
            
            if (curNote != -1)
            {
                int period = 111860.8 / MidiMessage::getMidiNoteInHertz (curNote) - 1;
                
                apu.write_register (0x4002, period & 0xFF);
                apu.write_register (0x4003, (period >> 8) & 0x7);
            }
            
            // Pulse 2
            apu.write_register (0x4004, (p2Duty << 6) | 0x30 | int (p2Level * v / 127.0 * 0xF));
            
            if (curNote != -1)
            {
                int period = 111860.8 / MidiMessage::getMidiNoteInHertz (curNote) - 1;
                
                apu.write_register (0x4006, period & 0xFF);
                apu.write_register (0x4007, (period >> 8) & 0x7);
            }
            
            // Triangle
            apu.write_register (0x4008, curNote == -1 ? 0x00 : 0xFF);
            if (curNote != -1)
            {
                int period = tLevel == 1.0f ? 111860.8 / (MidiMessage::getMidiNoteInHertz (curNote) * 2) - 1 : 0;
                
                apu.write_register (0x400A, period & 0xFF);
                apu.write_register (0x400B, (period >> 8) & 0x7);
            }
            
            // Noise
            apu.write_register (0x400C, 0x30 | int (nLevel * v / 127.0 * 0xF));
            
            if (curNote != -1)
            {
                apu.write_register (0x400E, (nShort ? 0x80 : 0x00) | (curNote % 16));
                apu.write_register (0x400F, 0xFF);
            }
            
            lastNote = curNote;
        }
    }
    
    runUntil (done, buffer, buffer.getNumSamples());
    
    outputLevel.trackBuffer (buffer);
}

//==============================================================================
bool RP2A03AudioProcessor::hasEditor() const
{
    return true;
}

AudioProcessorEditor* RP2A03AudioProcessor::createEditor()
{
    return new RP2A03AudioProcessorEditor (*this);
}

//==============================================================================
// This creates new instances of the plugin..
AudioProcessor* JUCE_CALLTYPE createPluginFilter()
{
    return new RP2A03AudioProcessor();
}
